<h1 align="center">可视化仿真实现作业管理与虚页内存管理</h1>

## :information_source:设计要求

在`多任务`的作业`并发`环境下，`仿真`实现作业及进程并发环境、`MMU 地址变换`、`进程原语`、`页表`生成与虚页调度算法（至少实现`LRU`）、`三级作业调度`过程及算法（需作业调度到指令集，至少实现`三态转换`）
、`页面分配与回收算法`、进程`同步互斥`、进程`死锁检测` 与 `撤销`算法，并将实现原理过程通过`可视化`方式呈现。

## :iphone:主界面

<img align="center" src="https://picturestr.oss-cn-shanghai.aliyuncs.com/img/20200430155807.png"/>

## :building_construction:程序结构

+ Job类	

  作业类，一个作业分1-5个任务
+ Task类	

  任务类，每个任务含有一个进程
+ Process类	

  进程类，包含20-300条指令
+ Instruct类	

  指令类

## :hammer:硬件设计
#### Job类
定义了一个作业类，开机时随机生成一到五个作业，通过作业来生成多个任务。对应的关系为，作业包含多个任务，一个任务包含一个进程# OS
操作系统课程设计，关键词：进程同步与互斥、进程死锁、LRU页面替换算法、时间片轮转算法、时钟等
#### Process类
定义了一个任务类，里面包含了进程所有的属性，同步标志位、进程状态等 
+ Instruct类
定义的指令类，用于进程调度执行
+ 界面组件设计
界面思路来源于任务管理器，管理进程的相关调度信息和CPU或内存物理块占用信息

   + JFrame
    图形界面组件，用于构造整个面板容器。该课设将Os继承于JFrame，可以减少文件数量，主要的界面函数写在Os.java文件里
    
   + JPanel
    界面面板，用于创建需要个图形界面。该组件支持常见四种界面布局，对于该设计界面主要有边框布局（BordLayout）、网格布局（GirdLayout）和流式布局（FlowLayout）
    
   + JTable
    表格组件，用于设计表格实时更新进程相关信息情况。该组件使用setValue（）函数可以实现实时更新数据
    
   + JScrollpan
   用于创建滚动条，当使用的文本数据太长，可以加入滚动条进行查看写入的信息
   
## :desktop_computer:进程调度
###  进程原语
+ public void create(Task task)
  + 函数输入：一个Task对象
  + 输出变量：无
  + 调用方法：每次创建进程时调用
  + 功能：进程创建原语
  
+ public void destroy()
  + 函数输入：一个Process对象
  + 输出变量：无
  + 调用方法：每次销毁进程时调用
  + 功能：进程销毁原语
  
+ public void block()
  + 函数输入：一个Process对象
  + 输出变量：无
  + 调用方法：每次阻塞进程时调用
  + 功能：进程阻塞原语
  
+ public void wake(Process process )
  + 函数输入：一个Process对象
  + 输出变量：无
  + 调用方法：每次唤醒进程时调用
  + 功能：进程唤醒原语
  
+ public void run_ready()
  + 函数输入：无
  + 输出变量：无
  + 调用方法：当处在运行态的进程运行完时间片转为就绪队列时调用
  + 功能：将进程在运行态和就绪态之间转换，如果执行完指令就撤销进程
  
  ![](https://picturestr.oss-cn-shanghai.aliyuncs.com/img/20200430160304.png)

### 时间片轮转算法
+ public void cpu_manage() 
  + 函数输入：无
  + 输出变量：无
  + 调用方法：在每次时钟中断时调用，即请求操作系统进行调度 
  + 功能：操作系统调度管理，cpu每次间隔十毫秒调度一次，根据指令的状态执行不同的操作

### 进程同步与互斥
+ 进程同步是把一对进程分别分别两部分，当该进程需要同步时把需要同步的进程PID赋值给同步标志位，让该进程执行一半后必须等待同步进程执行一半才能继续执行。

![](https://picturestr.oss-cn-shanghai.aliyuncs.com/img/20200430160409.png)

+ 进程互斥就是使用互斥信号量进行设计，如果信号量被占用则需要等待释放才能执行

![](https://picturestr.oss-cn-shanghai.aliyuncs.com/img/20200430160509.png)

### 进程死锁
进程死锁我们加入五种资源，查看是否能够分配资源，把所有不能够分配的进程和需要分配资源的进程都加入等待分配资源队列，然后使用银行家算法的预分配的办法进行检测能够分配则把从队列中剔除，不能的则全部阻塞。

## 总界面设计
### 模式选择界面
+ 随机生成模式

  此模式里面的指令类型、指令数目、进程数目、pv信号量占用等都是通过随机数生成
  
+ 读写文件模式

  此模式事通过读入文件里面的进程和指令信息进行赋值，然后执行相应的操作
  
  ![](https://picturestr.oss-cn-shanghai.aliyuncs.com/img/20200430160550.png)

### 裸机部件数据显示界面

+ CPU占用情况：

  CPU情况会显示占用的那个进程，指令条框显示执行到那条指令并且当前的物理地址显示
  
  ![](https://picturestr.oss-cn-shanghai.aliyuncs.com/img/20200430160639.png)

+ 时钟计时：

  时钟计时是以十的倍数进行则增加
  
  ![](https://picturestr.oss-cn-shanghai.aliyuncs.com/img/20200430160734.png)

+ 资源、内存、磁盘：

  资源显示当前的资源数，如果占用了则会减少。内存前半部分表示已经占用的内存，后面为总内存大小。磁盘表示总的磁盘设计大小。该界面展示基本硬件在本课设的详细设计情况和运行情况。
  
  ![](https://picturestr.oss-cn-shanghai.aliyuncs.com/img/20200430160804.png)

### 内存数据显示界面

 内存分为64个物理块，每个物理块为512B。每个物理块的展示情况都在界面上进行展示。
 
 ![](https://picturestr.oss-cn-shanghai.aliyuncs.com/img/20200430161123.png)

### 缺页中断显示界面

   发生缺页时用页面替换算法进行替换，将过程输出
   
   ![](https://picturestr.oss-cn-shanghai.aliyuncs.com/img/20200430161149.png)

### 进程调度过程显示

   进程调度过程是整个时间片轮转的过程，记录什么时刻有作业请求，什么时刻创建进程，那个进程进入了就绪队列还是运行队列。还有执行指令时记录详细的物理地址和逻辑地址。
   
   ![](https://picturestr.oss-cn-shanghai.aliyuncs.com/img/20200430160954.png)

### 四种调度过程分别显示

   通过创建两个面板，一个面板里面填充标签，另一个面板潜入四个面板，每个面板里面展示不同的界面，在不同的界面进行输出展示
   
   ![](https://picturestr.oss-cn-shanghai.aliyuncs.com/img/20200430161353.png)

## :woman_technologist:测试更新
### 增加程序计数器的输出

    用于详细的过程展示，将当前执行的指令进行输出
    
###  增加缺页中断图形界面的输出

    用于详细界面输出
    
## :film_projector:技术问题与解决方案

### 进程死锁问题

    死锁是指在一组进程中各个进程均占有不会释放的资源，但因互相申请被其他进程所占用不会释放的资源而处于的一种永久等待的状态。对于死锁的检测和资源分配情况，我们定义了五种资源，每个进程都会产生自己需要的资源，通过银行家算法进行资源预分配，看是否能够给与分配。如果能就把所有能分配资源的进程从等待资源队列中移除，剩下的就是不能分配的进程了，即死锁。
    
### 进程同步与互斥

   开始设想的同步，不太确定怎么能随机定义的十几个进程中让其同步。 既然是模拟同步，那就想到给进程一个同步标志位，标志位表示需要同步的进程，比如1号进程如果需要同步，则该同步标志位就是需要同步的进程PID；2号进程需要同步，则2号进程的同步标志位就是需要同步进程的PID。进程的互斥解决方案就是设置一个互斥信号量，看是否信号量被占用，如果被占用则进入阻塞队列，需要等待信号量释放。当另一个进程执行时释放了信号量，同时会唤醒阻塞队列的第一个进程。
   
### 界面设计

  思路来源于任务管理器，任务管理器的界面分为许多的板块，每个板块都有自己的布局和样式。但Java语言限制，只能用swing相关组件进行搭建。所以对于进程详细信息使用JTabel比格式布局更好，通过对每个Jpanel的四种布局搭配可以更好的呈现出近似于任务管理器布局的样式。

### 时间片轮状算法

   在第一次实验中，我用的是多级反馈队列算法，与此算法不同。在初次写时间片算法时。对于多种情况的讨论，起初没有加入进程同步与互斥，讨论了每种指令的类型，但是没有对是否分配资源，是否需要同步等进行讨论，在后期的整合中，我发现可以分开讨论，嵌套；调试之后就可以运行正确。

## :revolving_hearts:参考文献
[1]费翔林，骆斌.操作系统教程[M].5 版.北京：高等教育出版社，2014-2

[2]王道.2018操作系统考研复习指导[M].电子工业出版社

[3]银行家算法-概念&举例https://blog.csdn.net/wyf2017/article/details/80068608

[4]死锁产生的原因和解锁的方法.https://www.cnblogs.com/jing99/p/5947841.html

[5]操作系统之进程管理(2)--进程互斥与进程同步.https://www.cnblogs.com/exRunne
r/p/7576965.html

[6]Java图形化界面设计--容器.[阿朗].[博客园].https://www.cnblogs.com/aipan/p/6
409486.html

[7]Java中GUI-Swing组件.https://www.cnblogs.com/PengLee/p/3917479.html